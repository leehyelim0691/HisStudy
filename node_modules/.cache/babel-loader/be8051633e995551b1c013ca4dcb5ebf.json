{"ast":null,"code":"/**\n * @author Titus Wormer\n * @copyright 2015 Titus Wormer\n * @license MIT\n * @module remark:parse:tokenize:link\n * @fileoverview Tokenise a link.\n */\n'use strict';\n\nvar has = require('has');\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/link');\n\nmodule.exports = link;\nlink.locator = locate;\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_TICK = '`';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\n/* Map of characters, which can be used to mark link\n * and image titles. */\n\nvar LINK_MARKERS = {};\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n/* Map of characters, which can be used to mark link\n * and image titles in commonmark-mode. */\n\nvar COMMONMARK_LINK_MARKERS = {};\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n/* Tokenise a link. */\n\nfunction link(eat, value, silent) {\n  var self = this;\n  var subvalue = '';\n  var index = 0;\n  var character = value.charAt(0);\n  var commonmark = self.options.commonmark;\n  var gfm = self.options.gfm;\n  var closed;\n  var count;\n  var opening;\n  var beforeURL;\n  var beforeTitle;\n  var subqueue;\n  var hasMarker;\n  var markers;\n  var isImage;\n  var content;\n  var marker;\n  var length;\n  var title;\n  var depth;\n  var queue;\n  var url;\n  var now;\n  var exit;\n  var node;\n  /* Detect whether this is an image. */\n\n  if (character === '!') {\n    isImage = true;\n    subvalue = character;\n    character = value.charAt(++index);\n  }\n  /* Eat the opening. */\n\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n  /* Exit when this is a link and we’re already inside\n   * a link. */\n\n\n  if (!isImage && self.inLink) {\n    return;\n  }\n\n  subvalue += character;\n  queue = '';\n  index++;\n  /* Eat the content. */\n\n  length = value.length;\n  now = eat.now();\n  depth = 0;\n  now.column += index;\n  now.offset += index;\n\n  while (index < length) {\n    character = value.charAt(index);\n    subqueue = character;\n\n    if (character === C_TICK) {\n      /* Inline-code in link content. */\n      count = 1;\n\n      while (value.charAt(index + 1) === C_TICK) {\n        subqueue += character;\n        index++;\n        count++;\n      }\n\n      if (!opening) {\n        opening = count;\n      } else if (count >= opening) {\n        opening = 0;\n      }\n    } else if (character === C_BACKSLASH) {\n      /* Allow brackets to be escaped. */\n      index++;\n      subqueue += value.charAt(index);\n      /* In GFM mode, brackets in code still count.\n       * In all other modes, they don’t.  This empty\n       * block prevents the next statements are\n       * entered. */\n    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n      depth++;\n    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n      if (depth) {\n        depth--;\n      } else {\n        /* Allow white-space between content and\n         * url in GFM mode. */\n        if (gfm) {\n          while (index < length) {\n            character = value.charAt(index + 1);\n\n            if (!whitespace(character)) {\n              break;\n            }\n\n            subqueue += character;\n            index++;\n          }\n        }\n\n        if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n          return;\n        }\n\n        subqueue += C_PAREN_OPEN;\n        closed = true;\n        index++;\n        break;\n      }\n    }\n\n    queue += subqueue;\n    subqueue = '';\n    index++;\n  }\n  /* Eat the content closing. */\n\n\n  if (!closed) {\n    return;\n  }\n\n  content = queue;\n  subvalue += queue + subqueue;\n  index++;\n  /* Eat white-space. */\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n  /* Eat the URL. */\n\n\n  character = value.charAt(index);\n  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n    beforeURL += C_LT;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_GT) {\n        break;\n      }\n\n      if (commonmark && character === '\\n') {\n        return;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n      return;\n    }\n\n    subvalue += C_LT + queue + C_GT;\n    url = queue;\n    index++;\n  } else {\n    character = null;\n    subqueue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (subqueue && has(markers, character)) {\n        break;\n      }\n\n      if (whitespace(character)) {\n        if (commonmark) {\n          break;\n        }\n\n        subqueue += character;\n      } else {\n        if (character === C_PAREN_OPEN) {\n          depth++;\n        } else if (character === C_PAREN_CLOSE) {\n          if (depth === 0) {\n            break;\n          }\n\n          depth--;\n        }\n\n        queue += subqueue;\n        subqueue = '';\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        queue += character;\n      }\n\n      index++;\n    }\n\n    subvalue += queue;\n    url = queue;\n    index = subvalue.length;\n  }\n  /* Eat white-space. */\n\n\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  subvalue += queue;\n  /* Eat the title. */\n\n  if (queue && has(markers, character)) {\n    index++;\n    subvalue += character;\n    queue = '';\n    marker = markers[character];\n    beforeTitle = subvalue;\n    /* In commonmark-mode, things are pretty easy: the\n     * marker cannot occur inside the title.\n     *\n     * Non-commonmark does, however, support nested\n     * delimiters. */\n\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          break;\n        }\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        index++;\n        queue += character;\n      }\n\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        return;\n      }\n\n      title = queue;\n      subvalue += queue + character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (!whitespace(character)) {\n          break;\n        }\n\n        subvalue += character;\n        index++;\n      }\n    } else {\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue;\n            subqueue = '';\n          }\n\n          hasMarker = true;\n        } else if (!hasMarker) {\n          queue += character;\n        } else if (character === C_PAREN_CLOSE) {\n          subvalue += queue + marker + subqueue;\n          title = queue;\n          break;\n        } else if (whitespace(character)) {\n          subqueue += character;\n        } else {\n          queue += marker + subqueue + character;\n          subqueue = '';\n          hasMarker = false;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  if (value.charAt(index) !== C_PAREN_CLOSE) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  subvalue += C_PAREN_CLOSE;\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end);\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end;\n    title = self.decode.raw(self.unescape(title), beforeTitle);\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  };\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  } else {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  }\n\n  return eat(subvalue)(node);\n}","map":{"version":3,"sources":["/Users/hyerm2/Desktop/2021SWFestival/HisStudy/node_modules/remark-parse/lib/tokenize/link.js"],"names":["has","require","whitespace","locate","module","exports","link","locator","C_BACKSLASH","C_BRACKET_OPEN","C_BRACKET_CLOSE","C_PAREN_OPEN","C_PAREN_CLOSE","C_LT","C_GT","C_TICK","C_DOUBLE_QUOTE","C_SINGLE_QUOTE","LINK_MARKERS","COMMONMARK_LINK_MARKERS","eat","value","silent","self","subvalue","index","character","charAt","commonmark","options","gfm","closed","count","opening","beforeURL","beforeTitle","subqueue","hasMarker","markers","isImage","content","marker","length","title","depth","queue","url","now","exit","node","inLink","column","offset","decode","raw","unescape","test","end","type","alt","enterLink","children","tokenizeInline"],"mappings":"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","sourcesContent":["/**\n * @author Titus Wormer\n * @copyright 2015 Titus Wormer\n * @license MIT\n * @module remark:parse:tokenize:link\n * @fileoverview Tokenise a link.\n */\n\n'use strict';\n\nvar has = require('has');\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\n\nmodule.exports = link;\nlink.locator = locate;\n\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_TICK = '`';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\n\n/* Map of characters, which can be used to mark link\n * and image titles. */\nvar LINK_MARKERS = {};\n\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n\n/* Map of characters, which can be used to mark link\n * and image titles in commonmark-mode. */\nvar COMMONMARK_LINK_MARKERS = {};\n\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n\n/* Tokenise a link. */\nfunction link(eat, value, silent) {\n  var self = this;\n  var subvalue = '';\n  var index = 0;\n  var character = value.charAt(0);\n  var commonmark = self.options.commonmark;\n  var gfm = self.options.gfm;\n  var closed;\n  var count;\n  var opening;\n  var beforeURL;\n  var beforeTitle;\n  var subqueue;\n  var hasMarker;\n  var markers;\n  var isImage;\n  var content;\n  var marker;\n  var length;\n  var title;\n  var depth;\n  var queue;\n  var url;\n  var now;\n  var exit;\n  var node;\n\n  /* Detect whether this is an image. */\n  if (character === '!') {\n    isImage = true;\n    subvalue = character;\n    character = value.charAt(++index);\n  }\n\n  /* Eat the opening. */\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  /* Exit when this is a link and we’re already inside\n   * a link. */\n  if (!isImage && self.inLink) {\n    return;\n  }\n\n  subvalue += character;\n  queue = '';\n  index++;\n\n  /* Eat the content. */\n  length = value.length;\n  now = eat.now();\n  depth = 0;\n\n  now.column += index;\n  now.offset += index;\n\n  while (index < length) {\n    character = value.charAt(index);\n    subqueue = character;\n\n    if (character === C_TICK) {\n      /* Inline-code in link content. */\n      count = 1;\n\n      while (value.charAt(index + 1) === C_TICK) {\n        subqueue += character;\n        index++;\n        count++;\n      }\n\n      if (!opening) {\n        opening = count;\n      } else if (count >= opening) {\n        opening = 0;\n      }\n    } else if (character === C_BACKSLASH) {\n      /* Allow brackets to be escaped. */\n      index++;\n      subqueue += value.charAt(index);\n    /* In GFM mode, brackets in code still count.\n     * In all other modes, they don’t.  This empty\n     * block prevents the next statements are\n     * entered. */\n    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n      depth++;\n    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n      if (depth) {\n        depth--;\n      } else {\n        /* Allow white-space between content and\n         * url in GFM mode. */\n        if (gfm) {\n          while (index < length) {\n            character = value.charAt(index + 1);\n\n            if (!whitespace(character)) {\n              break;\n            }\n\n            subqueue += character;\n            index++;\n          }\n        }\n\n        if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n          return;\n        }\n\n        subqueue += C_PAREN_OPEN;\n        closed = true;\n        index++;\n\n        break;\n      }\n    }\n\n    queue += subqueue;\n    subqueue = '';\n    index++;\n  }\n\n  /* Eat the content closing. */\n  if (!closed) {\n    return;\n  }\n\n  content = queue;\n  subvalue += queue + subqueue;\n  index++;\n\n  /* Eat white-space. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat the URL. */\n  character = value.charAt(index);\n  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n    beforeURL += C_LT;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_GT) {\n        break;\n      }\n\n      if (commonmark && character === '\\n') {\n        return;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n      return;\n    }\n\n    subvalue += C_LT + queue + C_GT;\n    url = queue;\n    index++;\n  } else {\n    character = null;\n    subqueue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (subqueue && has(markers, character)) {\n        break;\n      }\n\n      if (whitespace(character)) {\n        if (commonmark) {\n          break;\n        }\n\n        subqueue += character;\n      } else {\n        if (character === C_PAREN_OPEN) {\n          depth++;\n        } else if (character === C_PAREN_CLOSE) {\n          if (depth === 0) {\n            break;\n          }\n\n          depth--;\n        }\n\n        queue += subqueue;\n        subqueue = '';\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        queue += character;\n      }\n\n      index++;\n    }\n\n    subvalue += queue;\n    url = queue;\n    index = subvalue.length;\n  }\n\n  /* Eat white-space. */\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  subvalue += queue;\n\n  /* Eat the title. */\n  if (queue && has(markers, character)) {\n    index++;\n    subvalue += character;\n    queue = '';\n    marker = markers[character];\n    beforeTitle = subvalue;\n\n    /* In commonmark-mode, things are pretty easy: the\n     * marker cannot occur inside the title.\n     *\n     * Non-commonmark does, however, support nested\n     * delimiters. */\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          break;\n        }\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        index++;\n        queue += character;\n      }\n\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        return;\n      }\n\n      title = queue;\n      subvalue += queue + character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (!whitespace(character)) {\n          break;\n        }\n\n        subvalue += character;\n        index++;\n      }\n    } else {\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue;\n            subqueue = '';\n          }\n\n          hasMarker = true;\n        } else if (!hasMarker) {\n          queue += character;\n        } else if (character === C_PAREN_CLOSE) {\n          subvalue += queue + marker + subqueue;\n          title = queue;\n          break;\n        } else if (whitespace(character)) {\n          subqueue += character;\n        } else {\n          queue += marker + subqueue + character;\n          subqueue = '';\n          hasMarker = false;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  if (value.charAt(index) !== C_PAREN_CLOSE) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  subvalue += C_PAREN_CLOSE;\n\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end);\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end;\n    title = self.decode.raw(self.unescape(title), beforeTitle);\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  };\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  } else {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  }\n\n  return eat(subvalue)(node);\n}\n"]},"metadata":{},"sourceType":"script"}